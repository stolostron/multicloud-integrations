/*


Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitopscluster

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	v1 "k8s.io/api/core/v1"
	"k8s.io/klog"
	spokeclusterv1 "open-cluster-management.io/api/cluster/v1"
	gitopsclusterV1beta1 "open-cluster-management.io/multicloud-integrations/pkg/apis/apps/v1beta1"
	"open-cluster-management.io/multicloud-integrations/pkg/utils"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	authv1beta1 "open-cluster-management.io/managed-serviceaccount/apis/authentication/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

const componentName = "application-manager"

// GetAllManagedClusterSecretsInArgo returns list of secrets from all ACM GitOps managed cluster.
func (r *ReconcileGitOpsCluster) GetAllManagedClusterSecretsInArgo() (v1.SecretList, error) {
	klog.Info("Getting all managed cluster secrets from argo namespaces")

	secretList := &v1.SecretList{}
	listopts := &client.ListOptions{}

	secretSelector := &metav1.LabelSelector{
		MatchLabels: map[string]string{
			"apps.open-cluster-management.io/acm-cluster": "true",
			"argocd.argoproj.io/secret-type":              "cluster",
		},
	}

	secretSelectionLabel, err := utils.ConvertLabels(secretSelector)
	if err != nil {
		klog.Error("Failed to convert managed cluster secret selector, err:", err)
		return *secretList, err
	}

	listopts.LabelSelector = secretSelectionLabel
	err = r.List(context.TODO(), secretList, listopts)

	if err != nil {
		klog.Error("Failed to list managed cluster secrets in argo, err:", err)
		return *secretList, err
	}

	return *secretList, nil
}

// GetAllNonAcmManagedClusterSecretsInArgo returns list of secrets from all GitOps managed cluster.
// these secrets are not generated by ACM ArgoCD push model, they are created by end users themselves
func (r *ReconcileGitOpsCluster) GetAllNonAcmManagedClusterSecretsInArgo(argoNs string) (map[string][]*v1.Secret, error) {
	klog.Info("Getting all non-acm managed cluster secrets from argo namespaces")

	secretMap := make(map[string][]*v1.Secret, 0)

	secretList := &v1.SecretList{}
	listopts := &client.ListOptions{}

	secretSelector := &metav1.LabelSelector{
		MatchLabels: map[string]string{
			"argocd.argoproj.io/secret-type": "cluster",
		},
		MatchExpressions: []metav1.LabelSelectorRequirement{
			{
				Key:      "apps.open-cluster-management.io/acm-cluster",
				Operator: metav1.LabelSelectorOpDoesNotExist,
			},
		},
	}

	secretSelectionLabel, err := utils.ConvertLabels(secretSelector)

	if err != nil {
		klog.Error("Failed to convert managed cluster secret selector, err:", err)
		return secretMap, err
	}

	listopts.LabelSelector = secretSelectionLabel
	listopts.Namespace = argoNs

	err = r.List(context.TODO(), secretList, listopts)

	if err != nil {
		klog.Error("Failed to list managed cluster secrets in argo, err:", err)
		return secretMap, err
	}

	for _, secret := range secretList.Items {
		clusterName := secret.Data["name"]
		if len(clusterName) > 0 {
			secretMap[string(clusterName)] = append(secretMap[string(clusterName)], &secret)
		}
	}

	return secretMap, nil
}

// AddManagedClustersToArgo copies a managed cluster secret from the managed cluster namespace to ArgoCD namespace
func (r *ReconcileGitOpsCluster) AddManagedClustersToArgo(
	gitOpsCluster *gitopsclusterV1beta1.GitOpsCluster, managedClusters []*spokeclusterv1.ManagedCluster,
	orphanSecretsList map[types.NamespacedName]string, createBlankClusterSecrets bool) error {
	var returnErrs error
	errorOccurred := false
	argoNamespace := gitOpsCluster.Spec.ArgoServer.ArgoNamespace

	nonAcmClusterSecrets, err := r.GetAllNonAcmManagedClusterSecretsInArgo(argoNamespace)
	if err != nil {
		klog.Error("failed to get all non-acm managed cluster secrets. err: ", err.Error())

		return err
	}

	for _, managedCluster := range managedClusters {
		var newSecret *v1.Secret
		msaExists := false
		managedClusterSecret := &v1.Secret{}
		secretObjectKey := types.NamespacedName{
			Name:      managedCluster.Name + clusterSecretSuffix,
			Namespace: argoNamespace,
		}
		msaSecretObjectKey := types.NamespacedName{
			Name:      managedCluster.Name + "-" + componentName + clusterSecretSuffix,
			Namespace: argoNamespace,
		}

		// Remove the secrets from orphan list if we are supposed to create them
		// If we don't create them, they should be added back to orphan list at end of each iteration
		saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

		// check for Placement spec defined
		clusterApplyMode := ""
		if gitOpsCluster.Spec.PlacementRef == nil {
			continue
		}

		if createBlankClusterSecrets || gitOpsCluster.Spec.ManagedServiceAccountRef == "" {
			// check for a ManagedServiceAccount to see if we need to create the secret
			ManagedServiceAccount := &authv1beta1.ManagedServiceAccount{}
			ManagedServiceAccountName := types.NamespacedName{Namespace: managedCluster.Name, Name: componentName}
			err = r.Get(context.TODO(), ManagedServiceAccountName, ManagedServiceAccount)

			if err == nil {
				// get ManagedServiceAccount secret
				managedClusterSecretKey := types.NamespacedName{Name: componentName, Namespace: managedCluster.Name}
				err = r.Get(context.TODO(), managedClusterSecretKey, managedClusterSecret)

				if err == nil {
					klog.Infof("Found ManagedServiceAccount %s created by managed cluster %s", componentName, managedCluster.Name)
					msaExists = true
				} else {
					if !createBlankClusterSecrets {
						klog.Error("failed to find ManagedServiceAccount created secret application-manager")
						saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)
						continue
					}
				}
			} else {
				// fallback to old code
				if !createBlankClusterSecrets {
					klog.Infof("Failed to find ManagedServiceAccount CR in namespace %s", managedCluster.Name)
				}
				secretName := managedCluster.Name + clusterSecretSuffix
				managedClusterSecretKey := types.NamespacedName{Name: secretName, Namespace: managedCluster.Name}

				err = r.Get(context.TODO(), managedClusterSecretKey, managedClusterSecret)

				if err != nil {
					// try with CreateManagedClusterSecretFromManagedServiceAccount generated name
					secretName = managedCluster.Name + "-" + componentName + clusterSecretSuffix
					managedClusterSecretKey = types.NamespacedName{Name: secretName, Namespace: managedCluster.Name}
					err = r.Get(context.TODO(), managedClusterSecretKey, managedClusterSecret)
				}
			}

			// managed cluster secret doesn't need to exist for pull model
			if err != nil && !createBlankClusterSecrets {
				klog.Error("failed to get managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}

			if msaExists {
				newSecret, err = r.CreateManagedClusterSecretFromManagedServiceAccount(
					argoNamespace, managedCluster, componentName, false)
			} else {
				newSecret, err = r.CreateManagedClusterSecretInArgo(
					argoNamespace, managedClusterSecret, managedCluster, createBlankClusterSecrets)
			}

			if err != nil {
				klog.Error("failed to create managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		} else {
			klog.Infof("create cluster secret using managed service account: %s/%s", managedCluster.Name, gitOpsCluster.Spec.ManagedServiceAccountRef)

			newSecret, err = r.CreateManagedClusterSecretFromManagedServiceAccount(argoNamespace, managedCluster, gitOpsCluster.Spec.ManagedServiceAccountRef, true)
			if err != nil {
				klog.Error("failed to create managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		}

		existingManagedClusterSecret := &v1.Secret{}

		err = r.Get(context.TODO(), types.NamespacedName{Name: newSecret.Name, Namespace: newSecret.Namespace}, existingManagedClusterSecret)
		if err == nil {
			// Merge with existing non ACM cluster secrets
			if nonAcmSecrets, found := nonAcmClusterSecrets[managedCluster.Name]; found {
				klog.Infof("Found non ACM cluster secrets for cluster %s, merging...", managedCluster.Name)
				for _, nonAcmSecret := range nonAcmSecrets {
					newSecret = unionSecretData(newSecret, nonAcmSecret)
				}
			}

			newSecret = unionSecretData(newSecret, existingManagedClusterSecret)

			err = r.Update(context.TODO(), newSecret)
			if err != nil {
				klog.Error("failed to update managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		} else {
			// Merge with existing non ACM cluster secrets
			if nonAcmSecrets, found := nonAcmClusterSecrets[managedCluster.Name]; found {
				klog.Infof("Found non ACM cluster secrets for cluster %s, merging...", managedCluster.Name)
				for _, nonAcmSecret := range nonAcmSecrets {
					newSecret = unionSecretData(newSecret, nonAcmSecret)
				}
			}

			err = r.Create(context.TODO(), newSecret)
			if err != nil {
				klog.Error("failed to create managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		}

		// Cleanup managed cluster secret from managed cluster namespace
		if msaExists {
			longLivedSecretKey := types.NamespacedName{
				Name:      managedCluster.Name + clusterSecretSuffix,
				Namespace: managedCluster.Name,
			}
			err := r.Get(context.TODO(), longLivedSecretKey, managedClusterSecret)
			if err == nil {
				klog.Infof("Deleting managed cluster secret %s from namespace %s as it is replaced by ManagedServiceAccount", longLivedSecretKey.Name, longLivedSecretKey.Namespace)
				err = r.Delete(context.TODO(), managedClusterSecret)
				if err != nil {
					klog.Error("failed to delete managed cluster secret. err: ", err.Error())

					errorOccurred = true
					returnErrs = errors.Join(returnErrs, err)

					continue
				}
			}
		}

		delete(orphanSecretsList, secretObjectKey)
		delete(orphanSecretsList, msaSecretObjectKey)

		// now check if the applyMode is specified for GitOps pull model
		if clusterApplyMode != "" {
			klog.Infof("The cluster applyMode is %s", clusterApplyMode)
		}
	}

	if !errorOccurred {
		return nil
	}

	return returnErrs
}

func saveClusterSecret(orphanSecretsList map[types.NamespacedName]string, secretObjectKey, msaSecretObjectKey types.NamespacedName) {
	delete(orphanSecretsList, secretObjectKey)
	delete(orphanSecretsList, msaSecretObjectKey)
}

// CreateManagedClusterSecretInArgo creates a managed cluster secret with specific metadata in Argo namespace
func (r *ReconcileGitOpsCluster) CreateManagedClusterSecretInArgo(argoNamespace string, managedClusterSecret *v1.Secret,
	managedCluster *spokeclusterv1.ManagedCluster, createBlankClusterSecrets bool) (*v1.Secret, error) {
	// create the new cluster secret in the argocd server namespace
	var newSecret *v1.Secret

	clusterURL := ""

	if createBlankClusterSecrets {
		newSecret = &v1.Secret{
			TypeMeta: metav1.TypeMeta{
				Kind:       "Secret",
				APIVersion: "v1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      managedCluster.Name + "-" + componentName + clusterSecretSuffix,
				Namespace: argoNamespace,
				Labels: map[string]string{
					"argocd.argoproj.io/secret-type":                 "cluster",
					"apps.open-cluster-management.io/acm-cluster":    "true",
					"apps.open-cluster-management.io/cluster-name":   managedCluster.Name,
					"apps.open-cluster-management.io/cluster-server": managedCluster.Name + "-control-plane", // dummy value for pull model
				},
			},
			Type: "Opaque",
			StringData: map[string]string{
				"name":   managedCluster.Name,
				"server": "https://" + managedCluster.Name + "-control-plane", // dummy value for pull model
			},
		}
	} else {
		var err error
		if string(managedClusterSecret.Data["server"]) == "" {
			clusterURL, err = getManagedClusterURL(managedCluster, string(managedClusterSecret.Data["token"]))
			if err != nil {
				klog.Error("failed to get managed cluster URL, err: ", err.Error())
				return newSecret, err
			}
		} else {
			clusterURL = string(managedClusterSecret.Data["server"])
		}

		newSecret = &v1.Secret{
			TypeMeta: metav1.TypeMeta{
				Kind:       "Secret",
				APIVersion: "v1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      managedCluster.Name + clusterSecretSuffix,
				Namespace: argoNamespace,
				Labels: map[string]string{
					"argocd.argoproj.io/secret-type":                 "cluster",
					"apps.open-cluster-management.io/acm-cluster":    "true",
					"apps.open-cluster-management.io/cluster-name":   managedCluster.Name,
					"apps.open-cluster-management.io/cluster-server": clusterURL,
				},
			},
			Type: "Opaque",
			StringData: map[string]string{
				"name":   managedCluster.Name,
				"server": clusterURL,
				"config": string(managedClusterSecret.Data["config"]),
			},
		}
	}

	// Collect labels to add to the secret
	// Labels created above have precedence
	for key, val := range managedCluster.Labels {
		if _, ok := newSecret.Labels[key]; !ok {
			newSecret.Labels[key] = val
		}
	}

	return newSecret, nil
}

// CreateManagedClusterSecretFromManagedServiceAccount creates secret from ManagedServiceAccount
func (r *ReconcileGitOpsCluster) CreateManagedClusterSecretFromManagedServiceAccount(argoNamespace string,
	managedCluster *spokeclusterv1.ManagedCluster, msaName string, useHostAsValue bool) (*v1.Secret, error) {

	if msaName == "" {
		return nil, fmt.Errorf("empty ManagedServiceAccount name")
	}

	var newSecret *v1.Secret

	// get ManagedServiceAccount
	ManagedServiceAccount := &authv1beta1.ManagedServiceAccount{}
	ManagedServiceAccountName := types.NamespacedName{Namespace: managedCluster.Name, Name: msaName}
	err := r.Get(context.TODO(), ManagedServiceAccountName, ManagedServiceAccount)

	if err != nil {
		klog.Errorf("failed to get ManagedServiceAccount: %s, err: %v", ManagedServiceAccountName.String(), err)
		return newSecret, err
	}

	if ManagedServiceAccount.Status.TokenSecretRef == nil {
		err := fmt.Errorf("ManagedServiceAccount %s doesn't have tokenSecretRef", ManagedServiceAccountName.String())
		klog.Error(err.Error())
		return newSecret, err
	}

	// get ManagedServiceAccount secret
	managedClusterSecret := &v1.Secret{}
	managedClusterSecretKey := types.NamespacedName{Name: ManagedServiceAccount.Status.TokenSecretRef.Name, Namespace: managedCluster.Name}
	err = r.Get(context.TODO(), managedClusterSecretKey, managedClusterSecret)

	if err != nil {
		klog.Errorf("failed to get ManagedServiceAccount secret: %s, err: %v", managedClusterSecretKey.String(), err)
		return newSecret, err
	}

	token, err := getManagedClusterToken(managedClusterSecret.Data["token"])
	if err != nil {
		klog.Error("failed to decode managed cluster secret token, err: ", err.Error())
		return newSecret, err
	}

	clusterURL, err := getManagedClusterURL(managedCluster, token)
	if err != nil {
		klog.Error("failed to get managed cluster URL, err: ", err.Error())
		return newSecret, err
	}

	clusterName := managedCluster.Name
	secretName := managedCluster.Name + "-" + msaName + clusterSecretSuffix

	if useHostAsValue {
		// when ManagedServiceAccountRef is specified we use actual host info from ManagedServiceAccount
		clusterName = clusterURL
		secretName = managedCluster.Name + clusterSecretSuffix
	}

	newSecret = &v1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: argoNamespace,
			Labels: map[string]string{
				"argocd.argoproj.io/secret-type":                 "cluster",
				"apps.open-cluster-management.io/acm-cluster":    "true",
				"apps.open-cluster-management.io/cluster-name":   managedCluster.Name,
				"apps.open-cluster-management.io/cluster-server": clusterURL,
			},
		},
		Type: "Opaque",
		StringData: map[string]string{
			"name":   clusterName,
			"server": clusterURL,
			"config": fmt.Sprintf(`{
  "bearerToken": "%s",
  "tlsClientConfig": {
    "insecure": false,
    "caData": "%s"
  }
}`,
				token,
				base64.StdEncoding.EncodeToString(managedClusterSecret.Data["ca.crt"]),
			),
		},
	}

	return newSecret, nil
}

func unionSecretData(newSecret, existingSecret *v1.Secret) *v1.Secret {
	// union of labels
	newLabels := newSecret.GetLabels()
	existingLabels := existingSecret.GetLabels()

	if newLabels == nil {
		newLabels = make(map[string]string)
	}

	if existingLabels == nil {
		existingLabels = make(map[string]string)
	}

	for key, val := range existingLabels {
		if _, ok := newLabels[key]; !ok {
			newLabels[key] = val
		}
	}

	newSecret.SetLabels(newLabels)

	// union of annotations
	newAnnotations := newSecret.GetAnnotations()
	existingAnnotations := existingSecret.GetAnnotations()

	if newAnnotations == nil {
		newAnnotations = make(map[string]string)
	}

	if existingAnnotations == nil {
		existingAnnotations = make(map[string]string)
	}

	for key, val := range existingAnnotations {
		if _, ok := newAnnotations[key]; !ok {
			if key != "kubectl.kubernetes.io/last-applied-configuration" {
				newAnnotations[key] = val
			}
		}
	}

	newSecret.SetAnnotations(newAnnotations)

	// union of data
	newData := newSecret.StringData
	existingData := existingSecret.Data // api never returns stringData as the field is write-only

	if newData == nil {
		newData = make(map[string]string)
	}

	if existingData == nil {
		existingData = make(map[string][]byte)
	}

	for key, val := range existingData {
		if _, ok := newData[key]; !ok {
			newData[key] = string(val[:])
		}
	}

	newSecret.StringData = newData

	return newSecret
}

func getManagedClusterToken(dataConfig []byte) (string, error) {
	if dataConfig == nil {
		return "", fmt.Errorf("empty secret data config")
	}

	// Unmarshal the decoded JSON into the Config struct
	var config map[string]interface{}
	if err := json.Unmarshal(dataConfig, &config); err != nil {
		return "", err
	}

	// Extract the bearer token
	return config["access_token"].(string), nil
}

func getManagedClusterURL(managedCluster *spokeclusterv1.ManagedCluster, token string) (string, error) {
	clientConfigs := managedCluster.Spec.ManagedClusterClientConfigs
	if len(clientConfigs) == 0 {
		err := fmt.Errorf("no client configs found for managed cluster: %v", managedCluster.Name)

		return "", err
	}

	clientConfig := clientConfigs[0]
	clusterURL := clientConfig.URL

	// Handle different URL formats
	if !strings.HasPrefix(clusterURL, "http://") && !strings.HasPrefix(clusterURL, "https://") {
		clusterURL = "https://" + clusterURL
	}

	return clusterURL, nil
}
