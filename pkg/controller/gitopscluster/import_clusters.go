/*


Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitopscluster

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"

	v1 "k8s.io/api/core/v1"
	k8errors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/klog"
	spokeclusterv1 "open-cluster-management.io/api/cluster/v1"
	gitopsclusterV1beta1 "open-cluster-management.io/multicloud-integrations/pkg/apis/apps/v1beta1"
	"open-cluster-management.io/multicloud-integrations/pkg/utils"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	authv1beta1 "open-cluster-management.io/managed-serviceaccount/apis/authentication/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

const componentName = "application-manager"

// GetAllManagedClusterSecretsInArgo returns list of secrets from all ACM GitOps managed cluster.
func (r *ReconcileGitOpsCluster) GetAllManagedClusterSecretsInArgo() (v1.SecretList, error) {
	klog.Info("Getting all managed cluster secrets from argo namespaces")

	secretList := &v1.SecretList{}
	listopts := &client.ListOptions{}

	secretSelector := &metav1.LabelSelector{
		MatchLabels: map[string]string{
			"apps.open-cluster-management.io/acm-cluster": "true",
			"argocd.argoproj.io/secret-type":              "cluster",
		},
	}

	secretSelectionLabel, err := utils.ConvertLabels(secretSelector)
	if err != nil {
		klog.Error("Failed to convert managed cluster secret selector, err:", err)
		return *secretList, err
	}

	listopts.LabelSelector = secretSelectionLabel
	err = r.List(context.TODO(), secretList, listopts)

	if err != nil {
		klog.Error("Failed to list managed cluster secrets in argo, err:", err)
		return *secretList, err
	}

	return *secretList, nil
}

// GetAllNonAcmManagedClusterSecretsInArgo returns list of secrets from all GitOps managed cluster.
// these secrets are not generated by ACM ArgoCD push model, they are created by end users themselves
func (r *ReconcileGitOpsCluster) GetAllNonAcmManagedClusterSecretsInArgo(argoNs string) (map[string][]*v1.Secret, error) {
	klog.Info("Getting all non-acm managed cluster secrets from argo namespaces")

	secretMap := make(map[string][]*v1.Secret, 0)

	secretList := &v1.SecretList{}
	listopts := &client.ListOptions{}

	secretSelector := &metav1.LabelSelector{
		MatchLabels: map[string]string{
			"argocd.argoproj.io/secret-type": "cluster",
		},
	}

	secretSelectionLabel, err := utils.ConvertLabels(secretSelector)
	if err != nil {
		klog.Error("Failed to convert managed cluster secret selector, err:", err)
		return secretMap, err
	}

	listopts.Namespace = argoNs

	listopts.LabelSelector = secretSelectionLabel
	err = r.List(context.TODO(), secretList, listopts)

	if err != nil {
		klog.Error("Failed to list managed cluster secrets in argo, err:", err)
		return secretMap, err
	}

	// Add non-ACM secrets to map by cluster name
	for i := range secretList.Items {
		s := secretList.Items[i]

		_, acmcluster := s.Labels["apps.open-cluster-management.io/acm-cluster"]
		if !acmcluster {
			cluster := s.Data["name"]

			if cluster != nil {
				secrets := secretMap[string(cluster)]
				if secrets == nil {
					secrets = []*v1.Secret{}
				}

				secrets = append(secrets, &s)
				secretMap[string(cluster)] = secrets
			}
		}
	}

	return secretMap, nil
}

// AddManagedClustersToArgo copies a managed cluster secret from the managed cluster namespace to ArgoCD namespace
func (r *ReconcileGitOpsCluster) AddManagedClustersToArgo(
	gitOpsCluster *gitopsclusterV1beta1.GitOpsCluster, managedClusters []*spokeclusterv1.ManagedCluster,
	orphanSecretsList map[types.NamespacedName]string, createBlankClusterSecrets bool) error {

	// Skip processing if there's no placement reference
	if gitOpsCluster.Spec.PlacementRef == nil {
		klog.Infof("No placement reference found in GitOpsCluster %s/%s, skipping managed cluster processing",
			gitOpsCluster.Namespace, gitOpsCluster.Name)
		return nil
	}

	var returnErrs error
	errorOccurred := false
	argoNamespace := gitOpsCluster.Spec.ArgoServer.ArgoNamespace

	nonAcmClusterSecrets, err := r.GetAllNonAcmManagedClusterSecretsInArgo(argoNamespace)
	if err != nil {
		klog.Error("failed to get all non-acm managed cluster secrets. err: ", err.Error())

		return err
	}

	for _, managedCluster := range managedClusters {
		klog.Infof("adding managed cluster %s to gitops namespace %s", managedCluster.Name, argoNamespace)

		var newSecret *v1.Secret
		msaExists := false
		managedClusterSecret := &v1.Secret{}
		secretObjectKey := types.NamespacedName{
			Name:      managedCluster.Name + clusterSecretSuffix,
			Namespace: argoNamespace,
		}
		msaSecretObjectKey := types.NamespacedName{
			Name:      managedCluster.Name + "-" + componentName + clusterSecretSuffix,
			Namespace: argoNamespace,
		}

		// Check if there are existing non-acm created cluster secrets
		if len(nonAcmClusterSecrets[managedCluster.Name]) > 0 {
			returnErr := fmt.Errorf("found existing non-ACM ArgoCD clusters secrets for cluster: %v", managedCluster)
			klog.Error(returnErr.Error())

			returnErrs = errors.Join(returnErrs, returnErr)
			errorOccurred = true

			saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

			continue
		}

		if createBlankClusterSecrets || gitOpsCluster.Spec.ManagedServiceAccountRef == "" {
			// check for a ManagedServiceAccount to see if we need to create the secret
			ManagedServiceAccount := &authv1beta1.ManagedServiceAccount{}
			ManagedServiceAccountName := types.NamespacedName{Namespace: managedCluster.Name, Name: componentName}
			err = r.Get(context.TODO(), ManagedServiceAccountName, ManagedServiceAccount)

			if err == nil {
				// get ManagedServiceAccount secret
				managedClusterSecretKey := types.NamespacedName{Name: componentName, Namespace: managedCluster.Name}
				err = r.Get(context.TODO(), managedClusterSecretKey, managedClusterSecret)

				if err == nil {
					klog.Infof("Found ManagedServiceAccount %s created by managed cluster %s", componentName, managedCluster.Name)
					msaExists = true
				} else {
					klog.Error("failed to find ManagedServiceAccount created secret application-manager")
					saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

					continue
				}
			} else {
				// fallback to old code
				klog.Infof("Failed to find ManagedServiceAccount CR in namespace %s", managedCluster.Name)
				secretName := managedCluster.Name + clusterSecretSuffix
				managedClusterSecretKey := types.NamespacedName{Name: secretName, Namespace: managedCluster.Name}

				err = r.Get(context.TODO(), managedClusterSecretKey, managedClusterSecret)

				if err != nil {
					// try with CreateManagedClusterSecretFromManagedServiceAccount generated name
					secretName = managedCluster.Name + "-" + componentName + clusterSecretSuffix
					managedClusterSecretKey = types.NamespacedName{Name: secretName, Namespace: managedCluster.Name}
					err = r.Get(context.TODO(), managedClusterSecretKey, managedClusterSecret)
				}
			}

			// managed cluster secret doesn't need to exist for pull model
			if err != nil && !createBlankClusterSecrets {
				klog.Error("failed to get managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}

			if msaExists {
				newSecret, err = r.CreateManagedClusterSecretFromManagedServiceAccount(
					argoNamespace, managedCluster, componentName, false)
			} else {
				newSecret, err = r.CreateManagedClusterSecretInArgo(
					argoNamespace, managedClusterSecret, managedCluster, createBlankClusterSecrets)
			}

			if err != nil {
				klog.Error("failed to create managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		} else {
			klog.Infof("create cluster secret using managed service account: %s/%s", managedCluster.Name, gitOpsCluster.Spec.ManagedServiceAccountRef)

			newSecret, err = r.CreateManagedClusterSecretFromManagedServiceAccount(argoNamespace, managedCluster, gitOpsCluster.Spec.ManagedServiceAccountRef, true)
			if err != nil {
				klog.Error("failed to create managed cluster secret. err: ", err.Error())

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		}

		existingManagedClusterSecret := &v1.Secret{}

		err = r.Get(context.TODO(), types.NamespacedName{Name: newSecret.Name, Namespace: newSecret.Namespace}, existingManagedClusterSecret)
		if err == nil {
			klog.Infof("updating managed cluster secret in argo namespace: %v/%v", newSecret.Namespace, newSecret.Name)

			newSecret = unionSecretData(newSecret, existingManagedClusterSecret)

			err := r.Update(context.TODO(), newSecret)

			if err != nil {
				klog.Errorf("failed to update managed cluster secret. name: %v/%v, error: %v", newSecret.Namespace, newSecret.Name, err)

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		} else if k8errors.IsNotFound(err) {
			klog.Infof("creating managed cluster secret in argo namespace: %v/%v", newSecret.Namespace, newSecret.Name)

			err := r.Create(context.TODO(), newSecret)

			if err != nil {
				klog.Errorf("failed to create managed cluster secret. name: %v/%v, error: %v", newSecret.Namespace, newSecret.Name, err)

				errorOccurred = true
				returnErrs = errors.Join(returnErrs, err)

				saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

				continue
			}
		} else {
			klog.Errorf("failed to get managed cluster secret. name: %v/%v, error: %v", newSecret.Namespace, newSecret.Name, err)

			errorOccurred = true
			returnErrs = errors.Join(returnErrs, err)

			saveClusterSecret(orphanSecretsList, secretObjectKey, msaSecretObjectKey)

			continue
		}

		// Cleanup managed cluster secret from managed cluster namespace
		if msaExists {
			longLivedSecretKey := types.NamespacedName{
				Name:      managedCluster.Name + clusterSecretSuffix,
				Namespace: managedCluster.Name,
			}
			err := r.Get(context.TODO(), longLivedSecretKey, managedClusterSecret)

			if err != nil && k8errors.IsNotFound(err) {
				klog.Infof("Long lived token secret cleaned up already")
			} else if err != nil && !k8errors.IsNotFound(err) {
				klog.Infof("Failed to get long lived token secret to cleaned up. Error: %v", err)
			} else {
				err = r.Delete(context.TODO(), managedClusterSecret)
				if err != nil {
					klog.Infof("Failed to clean up long lived token secret. Error %v", err)
				} else {
					klog.Infof("Cleaned up long lived token secret succefully")
				}
			}
		}

		// Managed cluster secret successfully created/updated - remove from orphan list
		delete(orphanSecretsList, client.ObjectKeyFromObject(newSecret))
	}

	if !errorOccurred {
		return nil
	}

	return returnErrs
}

func saveClusterSecret(orphanSecretsList map[types.NamespacedName]string, secretObjectKey, msaSecretObjectKey types.NamespacedName) {
	delete(orphanSecretsList, secretObjectKey)
	delete(orphanSecretsList, msaSecretObjectKey)
}

// CreateManagedClusterSecretInArgo creates a managed cluster secret with specific metadata in Argo namespace
func (r *ReconcileGitOpsCluster) CreateManagedClusterSecretInArgo(argoNamespace string, managedClusterSecret *v1.Secret,
	managedCluster *spokeclusterv1.ManagedCluster, createBlankClusterSecrets bool) (*v1.Secret, error) {
	// create the new cluster secret in the argocd server namespace
	var newSecret *v1.Secret

	clusterURL := ""

	if createBlankClusterSecrets {
		newSecret = &v1.Secret{
			TypeMeta: metav1.TypeMeta{
				Kind:       "Secret",
				APIVersion: "v1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      managedCluster.Name + "-" + componentName + clusterSecretSuffix,
				Namespace: argoNamespace,
				Labels: map[string]string{
					"argocd.argoproj.io/secret-type":                 "cluster",
					"apps.open-cluster-management.io/acm-cluster":    "true",
					"apps.open-cluster-management.io/cluster-name":   managedCluster.Name,
					"apps.open-cluster-management.io/cluster-server": managedCluster.Name + "-control-plane", // dummy value for pull model
				},
			},
			Type: "Opaque",
			StringData: map[string]string{
				"name":   managedCluster.Name,
				"server": "https://" + managedCluster.Name + "-control-plane", // dummy value for pull model
			},
		}
	} else {
		if string(managedClusterSecret.Data["server"]) == "" {
			clusterToken, err := getManagedClusterToken(managedClusterSecret.Data["config"])
			if err != nil {
				klog.Error(err)

				return nil, err
			}

			clusterURL, err = getManagedClusterURL(managedCluster, clusterToken)
			if err != nil {
				klog.Error(err)

				return nil, err
			}
		} else {
			clusterURL = string(managedClusterSecret.Data["server"])
		}

		labels := managedClusterSecret.GetLabels()

		newSecret = &v1.Secret{
			TypeMeta: metav1.TypeMeta{
				Kind:       "Secret",
				APIVersion: "v1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      managedClusterSecret.Name,
				Namespace: argoNamespace,
				Labels: map[string]string{
					"argocd.argoproj.io/secret-type":                 "cluster",
					"apps.open-cluster-management.io/acm-cluster":    "true",
					"apps.open-cluster-management.io/cluster-name":   labels["apps.open-cluster-management.io/cluster-name"],
					"apps.open-cluster-management.io/cluster-server": labels["apps.open-cluster-management.io/cluster-server"],
				},
			},
			Type: "Opaque",
			StringData: map[string]string{
				"config": string(managedClusterSecret.Data["config"]),
				"name":   string(managedClusterSecret.Data["name"]),
				"server": clusterURL,
			},
		}
	}

	// Collect labels to add to the secret
	// Labels created above have precedence
	for key, val := range managedCluster.Labels {
		if _, ok := newSecret.Labels[key]; !ok {
			newSecret.Labels[key] = val
		}
	}

	return newSecret, nil
}

func (r *ReconcileGitOpsCluster) CreateManagedClusterSecretFromManagedServiceAccount(argoNamespace string,
	managedCluster *spokeclusterv1.ManagedCluster, managedServiceAccountRef string, enableTLS bool) (*v1.Secret, error) {
	// Find managedserviceaccount in the managed cluster namespace
	account := &authv1beta1.ManagedServiceAccount{}
	if err := r.Get(context.TODO(), types.NamespacedName{Name: managedServiceAccountRef, Namespace: managedCluster.Name}, account); err != nil {
		klog.Errorf("failed to get managed service account: %v/%v", managedCluster.Name, managedServiceAccountRef)

		return nil, err
	}

	// Get secret from managedserviceaccount
	tokenSecretRef := account.Status.TokenSecretRef
	if tokenSecretRef == nil {
		err := fmt.Errorf("no token reference secret found in the managed service account: %v/%v", managedCluster.Name, managedServiceAccountRef)
		klog.Error(err)

		return nil, err
	}

	tokenSecret := &v1.Secret{}
	if err := r.Get(context.TODO(), types.NamespacedName{Name: tokenSecretRef.Name, Namespace: managedCluster.Name}, tokenSecret); err != nil {
		klog.Errorf("failed to get token secret: %v/%v", managedCluster.Name, tokenSecretRef.Name)

		return nil, err
	}

	clusterSecretName := fmt.Sprintf("%v-%v-cluster-secret", managedCluster.Name, managedServiceAccountRef)

	tlsClientConfig := map[string]interface{}{
		"insecure": true,
	}
	caCrt := base64.StdEncoding.EncodeToString(tokenSecret.Data["ca.crt"])

	if enableTLS {
		tlsClientConfig = map[string]interface{}{
			"insecure": false,
			"caData":   caCrt,
		}
	}

	config := map[string]interface{}{
		"bearerToken":     string(tokenSecret.Data["token"]),
		"tlsClientConfig": tlsClientConfig,
	}

	encodedConfig, err := json.Marshal(config)
	if err != nil {
		klog.Error(err, "failed to encode data for the cluster secret")

		return nil, err
	}

	clusterURL, err := getManagedClusterURL(managedCluster, string(tokenSecret.Data["token"]))
	if err != nil {
		klog.Error(err)

		return nil, err
	}

	klog.Infof("managed cluster %v, URL: %v", managedCluster.Name, clusterURL)

	// For use in label - remove the protocol and port (contains invalid characters for label)
	strippedClusterURL := clusterURL

	index := strings.Index(strippedClusterURL, "://")
	if index > 0 {
		strippedClusterURL = strippedClusterURL[index+3:]
	}

	index = strings.Index(strippedClusterURL, ":")
	if index > 0 {
		strippedClusterURL = strippedClusterURL[:index]
	}

	newSecret := &v1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      clusterSecretName,
			Namespace: argoNamespace,
			Labels: map[string]string{
				"argocd.argoproj.io/secret-type":                 "cluster",
				"apps.open-cluster-management.io/acm-cluster":    "true",
				"apps.open-cluster-management.io/cluster-name":   managedCluster.Name,
				"apps.open-cluster-management.io/cluster-server": fmt.Sprintf("%.63s", strippedClusterURL),
			},
		},
		Type: "Opaque",
		StringData: map[string]string{
			"config": string(encodedConfig),
			"name":   managedCluster.Name,
			"server": clusterURL,
		},
	}

	// Collect labels to add to the secret
	// Labels created above have precedence
	for key, val := range managedCluster.Labels {
		if _, ok := newSecret.Labels[key]; !ok {
			newSecret.Labels[key] = val
		}
	}

	return newSecret, nil
}

func unionSecretData(newSecret, existingSecret *v1.Secret) *v1.Secret {
	// union of labels
	newLabels := newSecret.GetLabels()
	existingLabels := existingSecret.GetLabels()

	if newLabels == nil {
		newLabels = make(map[string]string)
	}

	if existingLabels == nil {
		existingLabels = make(map[string]string)
	}

	for key, val := range existingLabels {
		if _, ok := newLabels[key]; !ok {
			newLabels[key] = val
		}
	}

	newSecret.SetLabels(newLabels)

	// union of annotations
	newAnnotations := newSecret.GetAnnotations()
	existingAnnotations := existingSecret.GetAnnotations()

	if newAnnotations == nil {
		newAnnotations = make(map[string]string)
	}

	if existingAnnotations == nil {
		existingAnnotations = make(map[string]string)
	}

	for key, val := range existingAnnotations {
		if _, ok := newAnnotations[key]; !ok {
			if key != "kubectl.kubernetes.io/last-applied-configuration" {
				newAnnotations[key] = val
			}
		}
	}

	newSecret.SetAnnotations(newAnnotations)

	// union of data
	newData := newSecret.StringData
	existingData := existingSecret.Data // api never returns stringData as the field is write-only

	if newData == nil {
		newData = make(map[string]string)
	}

	if existingData == nil {
		existingData = make(map[string][]byte)
	}

	for key, val := range existingData {
		if _, ok := newData[key]; !ok {
			newData[key] = string(val[:])
		}
	}

	newSecret.StringData = newData

	return newSecret
}

func getManagedClusterToken(dataConfig []byte) (string, error) {
	if dataConfig == nil {
		return "", fmt.Errorf("empty secret data config")
	}

	// Unmarshal the decoded JSON into the Config struct
	var config TokenConfig
	err := json.Unmarshal(dataConfig, &config)

	if err != nil {
		return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
	}

	if config.BearerToken == "" {
		return "", fmt.Errorf("bearerToken field is missing or empty")
	}

	return config.BearerToken, nil
}

func getManagedClusterURL(managedCluster *spokeclusterv1.ManagedCluster, token string) (string, error) {
	clientConfigs := managedCluster.Spec.ManagedClusterClientConfigs
	if len(clientConfigs) == 0 {
		err := fmt.Errorf("no client configs found for managed cluster: %v", managedCluster.Name)

		return "", err
	}

	// Helper function to ensure URL has https prefix
	addHTTPSPrefix := func(url string) string {
		if url == "" {
			return "https://"
		}
		// Trim whitespace for protocol detection but preserve original URL structure
		trimmed := strings.TrimSpace(url)
		if !strings.HasPrefix(trimmed, "http://") && !strings.HasPrefix(trimmed, "https://") {
			return "https://" + url
		}
		return url
	}

	// If only one clientconfig, always return it with https prefix if needed
	if len(clientConfigs) == 1 {
		return addHTTPSPrefix(clientConfigs[0].URL), nil
	}

	// For multiple configs, try to connect to each one and return the first accessible
	// If none are accessible, return the first URL as fallback
	firstURL := addHTTPSPrefix(clientConfigs[0].URL)

	for _, config := range clientConfigs {
		url := addHTTPSPrefix(config.URL)
		req, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			klog.Infof("error building new http request to %v", url)

			continue
		}

		req.Header.Set("Content-Type", "application/json")
		req.Header.Add("Authorization", "Bearer "+token)

		caCertPool := x509.NewCertPool()
		caCertPool.AppendCertsFromPEM(config.CABundle)

		httpClient := http.DefaultClient

		httpClient.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{
				RootCAs:    caCertPool,
				MinVersion: gitopsclusterV1beta1.TLSMinVersionInt, //#nosec G402
			},
		}

		resp, err := httpClient.Do(req)
		if err == nil {
			defer func() {
				if resp != nil {
					if err := resp.Body.Close(); err != nil {
						klog.Error("Error closing response: ", err)
					}
				}
			}()
			return url, nil
		}

		defer func() {
			if resp != nil {
				if err := resp.Body.Close(); err != nil {
					klog.Error("Error closing response: ", err)
				}
			}
		}()

		klog.Infof("error sending http request to %v, error: %v", url, err.Error())
	}

	// If no URL was accessible, return the first URL as fallback
	return firstURL, nil
}
